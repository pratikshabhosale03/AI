import heapq

class Node:
    def _init_(self, state, parent=None, g=0, h=0):
        self.state = state 
        self.parent = parent 
        self.g = g 
        self.h = h 

    def f(self):
        return self.g + self.h 

def astar_search(start_state, goal_state, heuristic, neighbors_func):
    open_set = [] 
    closed_set = set()
    start_node = Node(start_state, g=0, h=heuristic(start_state, goal_state))
    heapq.heappush(open_set, (start_node.f(), id(start_node), start_node))

    while open_set:
        _, _, current_node = heapq.heappop(open_set)
        if current_node.state == goal_state:
            path = []
            while current_node:
                path.append(current_node.state)
                current_node = current_node.parent
            return path[::-1]
        closed_set.add(current_node.state)

        for neighbor_state in neighbors_func(current_node.state):
            if neighbor_state in closed_set:
                continue
            g = current_node.g + 1 
            h = heuristic(neighbor_state, goal_state)
            neighbor_node = Node(neighbor_state, parent=current_node, g=g, 
h=h)
            heapq.heappush(open_set, (neighbor_node.f(), id(neighbor_node), neighbor_node))
    return None

def input_grid_world():
    grid = []
    rows = int(input("Enter the number of rows: "))
    cols = int(input("Enter the number of columns: "))
    print("Enter the grid (0 for empty, 1 for obstacles):")
    for _ in range(rows):
        row = list(map(int, input().split()))
        if len(row) != cols:
            print("Invalid input. Number of columns should be", cols)
            return None
        grid.append(row)
    return grid

def input_states(grid):
    rows = len(grid)
    cols = len(grid[0])
    print("Enter the start state (row column):")
    start_state = tuple(map(int, input().split()))
    if not (0 <= start_state[0] < rows and 0 <= start_state[1] < cols):
        print("Invalid start state")
        return None, None
    print("Enter the goal state (row column):")
    goal_state = tuple(map(int, input().split()))
    if not (0 <= goal_state[0] < rows and 0 <= goal_state[1] < cols):
        print("Invalid goal state")
        return None, None
    return start_state, goal_state

def manhattan_distance(state, goal_state):
    return abs(state[0] - goal_state[0]) + abs(state[1] - goal_state[1])

def get_neighbors(state, grid):
    neighbors = []
    row, col = state
    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
        new_row, new_col = row + dr, col + dc
        if 0 <= new_row < len(grid) and 0 <= new_col < len(grid[0]) and grid[new_row][new_col] == 0:
            neighbors.append((new_row, new_col))
    return neighbors

grid_world = input_grid_world()
if grid_world:
    start_state, goal_state = input_states(grid_world)
    if start_state and goal_state:
        path = astar_search(start_state, goal_state, manhattan_distance, lambda state: get_neighbors(state, grid_world))
        if path:
            print("Path found:", path)
        else:
            print("No path found")
